package ru.netology.nmedia.viewmodelimport android.app.Applicationimport androidx.coordinatorlayout.widget.CoordinatorLayout.Behavior.setTagimport androidx.lifecycle.*import kotlinx.coroutines.*import ru.netology.nmedia.dto.Postimport ru.netology.nmedia.repository.PostRepositoryimport ru.netology.nmedia.repository.PostRepositoryFileImplimport ru.netology.nmedia.util.SingleLiveEventimport java.io.Closeableimport kotlin.coroutines.CoroutineContextprivate const val JOB_KEY = "androidx.lifecycle.ViewModelCoroutineScope.JOB_KEY"private val empty = Post(0,"Me","","",0,false,0, null)class PostViewModel(application: Application) : AndroidViewModel(application) {    private val repository: PostRepository = PostRepositoryFileImpl(AppDb.getInstanse(context=application).postDao())    //    private val scope = MainScope()    val ViewModel.viewModelScope: CoroutineScope    get(){    val scope: CoroutineScope? = this.getTag(JOB_KEY)        if(scope != null) {        return scope    }        return setTagIfAbsent(JOB_KEY,            CloseableCoroutineScope(SupervisorJob()+ Dispatchers.Main.immediate))}    internal class CloseableCoroutineScope(context: CoroutineContext): Closeable, CoroutineScope{        override val coroutineContext: CoroutineContext = context        override fun close() {            coroutineContext.cancel()        }    }    val data: LiveData<FeedModel> = repository.data.map(::FeedModel)    private val _dataState = MutableLiveData<FeedModelState>()    val _dataState:LiveData<FeedModelState>    get() = _dataState//    private val edited = MutableLiveData(empty)//    private val _postCreated = SingleLiveEvent<Unit>()//    val postCreated: LiveData<Unit>//    get() = _postCreated//    private val _requestCode = MutableLiveData<Int>()//    val requestCode: LiveData<Int> = _requestCode    init {        loadPosts()    }    fun loadPosts() {            _data.value=FeedModel(loading = true)        viewModelScope.launch {            val posts = repository.getAll()            _data.value = FeedModel(posts=posts, empty=posts.isEmpty())        }    }    override fun onCleared() {        super.onCleared()        scope.cancel()    }    fun likeById(id:Long){        var oldPosts = _data.value?.posts.orEmpty()        repository.likeById(id,object :PostRepository.Callback<Post>{            override fun onSuccess(posts: Post) {                oldPosts = oldPosts.map{                    if (it.id != id) it else it.copy(                        likedByMe = posts.likedByMe,                        likes = posts.likes)                }                _data.value= FeedModel(posts = oldPosts)            }            override fun onError(e: Exception,code:Int) {                _data.value=FeedModel(error = true)                _requestCode.value=code            }        })    }    fun dislikeById(id:Long) {        var oldPosts = _data.value?.posts.orEmpty()        repository.likeById(id,object :PostRepository.Callback<Post>{            override fun onSuccess(posts: Post) {                oldPosts = oldPosts.map{                    if (it.id != id) it else it.copy(                        likedByMe = posts.likedByMe,                        likes = posts.likes)                }                _data.value=FeedModel(posts = oldPosts)            }            override fun onError(e: Exception,code:Int) {                _data.value=FeedModel(error = true)                _requestCode.value= code            }        })    }//        fun sharedById(id: Long) {//            thread {//                val old = _data.value?.posts.orEmpty()//                val posts = _data.value?.posts.orEmpty()//                posts.map {//                    if (it.id != id) it else it.copy()//                }//                try {//                    repository.sharedById(id)//                } catch (e: IOException) {//                    _data.postValue(_data.value?.copy(posts = old))//                }//            }////        }        fun refresh() {            loadPosts()        }        fun removeById(id: Long) {            repository.removeById(id,object :PostRepository.Callback<Post>{                override fun onSuccess(posts: Post) {                    _data.value=                        _data.value?.copy(posts = data.value?.posts.orEmpty()                            .filter { it.id!=id })                }                override fun onError(e: Exception,code:Int) {                    _data.value=FeedModel(error = true)                    _requestCode.value= code                }            })        }        fun save() {            edited.value?.let {                    repository.save(it, object:PostRepository.Callback<Post>{                        override fun onSuccess(posts: Post) {                            _postCreated.value=Unit                        }                        override fun onError(e: Exception,code:Int) {                            _data.value=FeedModel(error = true)                            _requestCode.value= code                        }                    } )                }            }        fun edit(post: Post) {            edited.value = post        }        fun editContent(content: String) {            edited.value.let {                val trimmed = content.trim()                if (edited.value?.content == trimmed) {                    return                }                edited.value = edited.value?.copy(content = trimmed)            }        }    }